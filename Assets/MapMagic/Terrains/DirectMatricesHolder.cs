using System;
using System.Collections.Generic;
using UnityEngine;

using Den.Tools;
using Den.Tools.Matrices;

namespace MapMagic.Terrains
{
	[ExecuteInEditMode]
	public class DirectMatricesHolder : MonoBehaviour, ISerializationCallbackReceiver
	/// For each tile stores dictionary of matrices generated by Direct Maps Output node
	{
		[NonSerialized] public DictionaryOrdered<string,MatrixWorld> maps = new DictionaryOrdered<string,MatrixWorld>();

		#region Matrix Helpers

			private MatrixWorld this[string name] 
			{get{
				if (maps.TryGetValue(name, out MatrixWorld matrix))
					return matrix;
				else
					throw new Exception($"Matrix with the name '{name}' is not found in dictionary");
			}}


			private static void CheckPosition (MatrixWorld matrix, float x, float z)
			{
				if (!matrix.ContainsWorldValue(x,z))
					throw new Exception($"Position {x},{z} is out of matrix bounds");
			}


			/// Checks if maps contain position given in world units (X and Z only).
			public bool ContainsPosition (float x, float z)
			{
				if (maps.Count == 0)
					return false;
				else
					return maps[0].ContainsWorldValue(x,z);
			}

			public bool ContainsPosition (Vector3 pos)
			{
				if (maps.Count == 0)
					return false;
				else
					return maps[0].ContainsWorldValue(pos.x, pos.z);
			}


			/// Selects the matrix by name (or number) and returns value at position given in world units.
			/// Position is floored to pixels, no interpolation
			public float ValueAtPosition (string name, float x, float z)  =>  this[name].GetWorldValue(x,z);
			public float ValueAtPosition (string name, Vector3 pos)  =>  this[name].GetWorldValue(pos.x, pos.z);
			public float ValueAtPosition (int num, float x, float z)  =>   maps[num].GetWorldValue(x,z);
			public float ValueAtPosition (int num, Vector3 pos)  =>   maps[num].GetWorldValue(pos.x, pos.z);


			/// Selects the matrix by number and returns value at position given in world units.
			/// Position is interpolated between closest pixels. Use this for precise operations.
			public float ValueAtPositionInterpolated (string name, float x, float z)  =>  this[name].GetWorldInterpolatedValue(x,z);
			public float ValueAtPositionInterpolated (string name, Vector3 pos)  =>  this[name].GetWorldInterpolatedValue(pos.x, pos.z);
			public float ValueAtPositionInterpolated (int num, float x, float z)  =>   maps[num].GetWorldInterpolatedValue(x,z);
			public float ValueAtPositionInterpolated (int num, Vector3 pos)  =>   maps[num].GetWorldInterpolatedValue(pos.x, pos.z);


			/// Finds all values at given world position, and returns them as name -> value dictionary. No interpolation.
			public Dictionary<string,float> AllValuesAtPosition (float x, float z)
			{
				Dictionary<string,float> result = new Dictionary<string, float>();
				foreach (var kvp in maps)
				{
					MatrixWorld matrix = kvp.Value;
					CheckPosition(matrix, x, z);

					result.Add(kvp.Key, matrix.GetWorldValue(x,z));
				}

				return result;
			}

		#endregion


		#region Examples

			/// Finds proper holder based on coordinate world position. 
			/// Null if not found.
			/// Uses GameObject.FindObjectOfType so it's not quick. Just an example.
			public static DirectMatricesHolder FindHolder (float x, float z)
			{
				DirectMatricesHolder[] holders = GameObject.FindObjectsOfType<DirectMatricesHolder>();

				foreach (DirectMatricesHolder holder in holders)
				{
					if (holder.ContainsPosition(x,z))
						return holder;
				}

				return null;
			}


			/// Finds a proper holder and evaluates position on a map with given name.
			/// In case we want to know biome or land texture value player currently in/on.
			/// 0 if player is out of any terrain.
			public static float FindValueAtPosition (string name, float x, float z)
			{
				DirectMatricesHolder holder = FindHolder(x, z);

				if (holder != null)
					return holder.ValueAtPosition(name, x, z);
				else
					return 0;
			}

			/// Finds a proper holder and evaluates position on a map with given name.
			/// Iterates directly on MapMagic tiles, so might be faster than previous one (however I have not checked).
			public static float FindValueAtPosition (MapMagic.Core.MapMagicObject mapMagicObject, string name, float x, float z)
			{
				TerrainTile tile = mapMagicObject.tiles.FindByWorldPosition(x, z);
				if (tile == null)
					return 0;

				DirectMatricesHolder holder = tile.ActiveTerrain.GetComponent<DirectMatricesHolder>();
				if (holder == null)
					return 0;

				return holder.ValueAtPosition(name, x, z);
			}

		#endregion

		#region Serialization
		[SerializeField] private string[] serNames;
			[SerializeField] private MatrixWorld[] serMaps;
			public void OnBeforeSerialize () => (serNames,serMaps) = maps.Serialize();
			public void OnAfterDeserialize () => maps.Deserialize(serNames,serMaps);
		#endregion
	}
}
